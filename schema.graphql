schema {
  query: Query
  mutation: Mutation
}

type ApiTokenNode implements Node {
  id: ID!
  name: String!
  createdAt: DateTime!
  lastUsedAt: DateTime
}

type ApiTokenNodeConnection {
  pageInfo: PageInfo!
  edges: [ApiTokenNodeEdge]!
}

type ApiTokenNodeEdge {
  node: ApiTokenNode
  cursor: String!
}

type ContactMail {
  ok: Boolean
  id: String
}

type CreateApiToken {
  success: Boolean
  token: String
  error: String
}

scalar Date

scalar DateTime

type DeleteApiToken {
  success: Boolean
  error: String
}

type DjangoDebug {
  sql: [DjangoDebugSQL]
}

type DjangoDebugSQL {
  vendor: String!
  alias: String!
  sql: String
  duration: Float!
  rawSql: String!
  params: String!
  startTime: Float!
  stopTime: Float!
  isSlow: Boolean!
  isSelect: Boolean!
  transId: String
  transStatus: String
  isoLevel: String
  encoding: String
}

enum EventEntryQuality {
  INCOMPLETE
  COMPLETE
}

input EventMutationInput {
  name: String!
  id: ID
  clientMutationId: String
}

type EventMutationPayload {
  event: EventNode
  clientMutationId: String
}

type EventNode implements Node {
  id: ID!
  name: String!
  website: String!
  slug: String
  flyerImage: String
  location: LocationNode
  organizer: OrganizerNode
  needsMedicalCertificate: Boolean
  needsLicense: Boolean
  soldOut: Boolean
  cancelled: Boolean
  invisible: Boolean
  withRanking: Boolean
  dateStart: Date!
  dateEnd: Date!
  waterTemp: Float
  description: String!
  internalComment: String!
  entryQuality: EventEntryQuality
  source: String
  createdAt: DateTime
  editedAt: DateTime
  verifiedAt: DateTime
  previousYearEvent: EventNode
  eventSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Icontains: String, website: String, location: ID, location_Country: String, location_City: String, location_City_Icontains: String, dateStart_Lte: Date, dateStart_Gte: Date, dateEnd_Lte: Date, dateEnd_Gte: Date): EventNodeConnection!
  races(offset: Int, before: String, after: String, first: Int, last: Int, distance_Lte: Float, distance_Gte: Float): RaceNodeConnection!
  reviews(offset: Int, before: String, after: String, first: Int, last: Int, event: ID): ReviewNodeConnection!
}

type EventNodeConnection {
  pageInfo: PageInfo!
  edges: [EventNodeEdge]!
}

type EventNodeEdge {
  node: EventNode
  cursor: String!
}

scalar ExpectedErrorType

enum LocationCountry {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

input LocationMutationInput {
  city: String!
  id: ID
  clientMutationId: String
}

type LocationMutationPayload {
  location: LocationNode
  clientMutationId: String
}

type LocationNode implements Node {
  city: String!
  waterName: String
  waterType: LocationWaterType
  country: LocationCountry!
  lat: Float
  lng: Float
  headerPhoto: String
  averageRating: Float
  events(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Icontains: String, website: String, location: ID, location_Country: String, location_City: String, location_City_Icontains: String, dateStart_Lte: Date, dateStart_Gte: Date, dateEnd_Lte: Date, dateEnd_Gte: Date): EventNodeConnection!
  id: ID!
}

type LocationNodeConnection {
  pageInfo: PageInfo!
  edges: [LocationNodeEdge]!
}

type LocationNodeEdge {
  node: LocationNode
  cursor: String!
}

enum LocationWaterType {
  RIVER
  SEA
  LAKE
  POOL
}

type Mutation {
  register(email: String!, username: String!, password1: String!, password2: String!): Register
  verifyAccount(token: String!): VerifyAccount
  tokenAuth(password: String!, email: String, username: String): ObtainJSONWebToken
  updateEvent(input: EventMutationInput!): EventMutationPayload
  updateLocation(input: LocationMutationInput!): LocationMutationPayload
  updateRace(input: RaceMutationInput!): RaceMutationPayload
  sendContactmail(message: String!, sender: String!): ContactMail
  rateEvent(comment: String, country: String, eventId: ID!, name: String, rating: Int!): RateEvent
  createApiToken(name: String!): CreateApiToken
  deleteApiToken(tokenId: ID!): DeleteApiToken
}

interface Node {
  id: ID!
}

type ObtainJSONWebToken {
  token: String
  success: Boolean
  errors: ExpectedErrorType
  user: UserNode
  unarchiving: Boolean
  refreshToken: String
}

type OrganizerNode implements Node {
  name: String!
  website: String!
  logo: String
  slug: String
  id: ID!
  numberOfEvents: Int
}

type OrganizerNodeConnection {
  pageInfo: PageInfo!
  edges: [OrganizerNodeEdge]!
}

type OrganizerNodeEdge {
  node: OrganizerNode
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  statistics: Statistics
  locationsFiltered(dateFrom: Date, dateTo: Date, raceDistanceGte: Float, raceDistanceLte: Float, keyword: String, eventSlug: String, organizerSlug: String, organizerId: ID): [LocationNode]
  me: UserNode
  user(id: ID!): UserNode
  users(offset: Int, before: String, after: String, first: Int, last: Int, email: String, username: String, username_Icontains: String, username_Istartswith: String, isActive: Boolean, status_Archived: Boolean, status_Verified: Boolean, status_SecondaryEmail: String): UserNodeConnection
  location(id: ID!): LocationNode
  allLocations(offset: Int, before: String, after: String, first: Int, last: Int, city: String, waterType: String, waterName: String, country: String, lat: Float, lng: Float, events: [ID], raceDistanceGte: Float, raceDistanceLte: Float, dateFrom: Date, dateTo: Date): LocationNodeConnection
  event(id: ID!): EventNode
  allEvents(offset: Int, before: String, after: String, first: Int, last: Int, dateFrom: Date, dateTo: Date, name: String, nameIcontains: String, website: String, location: ID, races: [ID], slug: String, raceDistanceGte: Float, raceDistanceLte: Float): EventNodeConnection
  race(id: ID!): RaceNode
  organizer(id: ID!): OrganizerNode
  allOrganizers(numberOfEventsGt: Int, offset: Int, before: String, after: String, first: Int, last: Int, name: String, slug: String): OrganizerNodeConnection
  myApiTokens: [ApiTokenNode]
  _debug: DjangoDebug
}

input RaceMutationInput {
  id: ID!
  coordinates: [Float]
  distance: Float
  raceTime: Time
  name: String
  wetsuit: String
  priceValue: Float
  priceCurrency: String
  clientMutationId: String
}

type RaceMutationPayload {
  race: RaceNode
  clientMutationId: String
}

type RaceNode implements Node {
  date: Date!
  raceTime: Time
  distance: Float!
  coordinates: [[Float!]]
  name: String
  wetsuit: RaceWetsuit
  priceCurrency: RacePriceCurrency!
  id: ID!
  priceValue: String
}

type RaceNodeConnection {
  pageInfo: PageInfo!
  edges: [RaceNodeEdge]!
}

type RaceNodeEdge {
  node: RaceNode
  cursor: String!
}

enum RacePriceCurrency {
  XUA
  AFN
  DZD
  ARS
  AMD
  AWG
  AUD
  AZN
  BSD
  BHD
  THB
  PAB
  BBD
  BYN
  BYR
  BZD
  BMD
  BTN
  VEF
  BOB
  XBA
  BRL
  BND
  BGN
  BIF
  XOF
  XAF
  XPF
  CAD
  CVE
  KYD
  CLP
  XTS
  COP
  KMF
  CDF
  BAM
  NIO
  CRC
  HRK
  CUP
  CUC
  CZK
  GMD
  DKK
  MKD
  DJF
  STD
  DOP
  VND
  XCD
  EGP
  SVC
  ETB
  EUR
  XBB
  XBD
  XBC
  FKP
  FJD
  HUF
  GHS
  GIP
  XAU
  XFO
  PYG
  GNF
  GYD
  HTG
  HKD
  UAH
  ISK
  INR
  IRR
  IQD
  IMP
  JMD
  JOD
  KES
  PGK
  LAK
  KWD
  AOA
  MMK
  GEL
  LVL
  LBP
  ALL
  HNL
  SLL
  LSL
  LRD
  LYD
  SZL
  LTL
  MGA
  MWK
  MYR
  TMM
  MUR
  MZN
  MXV
  MXN
  MDL
  MAD
  BOV
  NGN
  ERN
  NAD
  NPR
  ANG
  ILS
  RON
  TWD
  NZD
  KPW
  NOK
  PEN
  MRO
  TOP
  PKR
  XPD
  MOP
  PHP
  XPT
  GBP
  BWP
  QAR
  GTQ
  ZAR
  OMR
  KHR
  MVR
  IDR
  RUB
  RWF
  XDR
  SHP
  SAR
  RSD
  SCR
  XAG
  SGD
  SBD
  KGS
  SOS
  TJS
  SSP
  LKR
  XSU
  SDG
  SRD
  SEK
  CHF
  SYP
  BDT
  WST
  TZS
  KZT
  XXX
  TTD
  MNT
  TND
  TRY
  TMT
  TVD
  AED
  XFU
  USD
  USN
  UGX
  CLF
  COU
  UYI
  UYU
  UZS
  VUV
  CHE
  CHW
  KRW
  YER
  JPY
  CNY
  ZMK
  ZMW
  ZWD
  ZWN
  ZWL
  PLN
}

enum RaceWetsuit {
  COMPULSORY
  OPTIONAL
  PROHIBITED
}

type RateEvent {
  success: Boolean
  id: Int
}

type Register {
  success: Boolean
  errors: ExpectedErrorType
  refreshToken: String
  token: String
}

enum ReviewCountry {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

type ReviewNode implements Node {
  createdAt: DateTime!
  rating: Int
  comment: String
  name: String
  country: ReviewCountry
  id: ID!
}

type ReviewNodeConnection {
  pageInfo: PageInfo!
  edges: [ReviewNodeEdge]!
}

type ReviewNodeEdge {
  node: ReviewNode
  cursor: String!
}

type Statistics {
  eventCount: Int
  raceCount: Int
  countriesCount: Int
}

scalar Time

type UserNode implements Node {
  id: ID!
  lastLogin: DateTime
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  createdEvent(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Icontains: String, website: String, location: ID, location_Country: String, location_City: String, location_City_Icontains: String, dateStart_Lte: Date, dateStart_Gte: Date, dateEnd_Lte: Date, dateEnd_Gte: Date): EventNodeConnection!
  editedEvent(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Icontains: String, website: String, location: ID, location_Country: String, location_City: String, location_City_Icontains: String, dateStart_Lte: Date, dateStart_Gte: Date, dateEnd_Lte: Date, dateEnd_Gte: Date): EventNodeConnection!
  reviews(offset: Int, before: String, after: String, first: Int, last: Int, event: ID): ReviewNodeConnection!
  apiTokens(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Icontains: String): ApiTokenNodeConnection!
  pk: Int
  archived: Boolean
  verified: Boolean
  secondaryEmail: String
}

type UserNodeConnection {
  pageInfo: PageInfo!
  edges: [UserNodeEdge]!
}

type UserNodeEdge {
  node: UserNode
  cursor: String!
}

type VerifyAccount {
  success: Boolean
  errors: ExpectedErrorType
}
