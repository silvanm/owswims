# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

"Debugging information for the current query."
type DjangoDebug {
    "Executed SQL queries for this API query."
    sql: [DjangoDebugSQL]
}

"Represents a single database query made to a Django managed DB."
type DjangoDebugSQL {
    "The Django database alias (e.g. 'default')."
    alias: String!
    "Duration of this database query in seconds."
    duration: Float!
    "Postgres connection encoding if available."
    encoding: String
    "Whether this database query was a SELECT."
    isSelect: Boolean!
    "Whether this database query took more than 10 seconds."
    isSlow: Boolean!
    "Postgres isolation level if available."
    isoLevel: String
    "JSON encoded database query parameters."
    params: String!
    "The raw SQL of this query, without params."
    rawSql: String!
    "The actual SQL sent to this database."
    sql: String
    "Start time of this database query."
    startTime: Float!
    "Stop time of this database query."
    stopTime: Float!
    "Postgres transaction ID if available."
    transId: String
    "Postgres transaction status if available."
    transStatus: String
    "The type of database being used (e.g. postrgesql, mysql, sqlite)."
    vendor: String!
}

type EventMutationPayload {
    clientMutationId: String
    event: EventNode
}

type EventNode implements Node {
    cancelled: Boolean
    dateEnd: Date!
    dateStart: Date!
    "Comment shown to the public"
    description: String!
    "Timestamp of the last edit"
    editedAt: DateTime
    entryQuality: EventEntryQuality
    flyerImage: String
    "The ID of the object."
    id: ID!
    "Comment NOT shown to the public"
    internalComment: String!
    "Hidden from public"
    invisible: Boolean
    location: LocationNode
    name: String!
    needsLicense: Boolean
    needsMedicalCertificate: Boolean
    organizer: OrganizerNode
    races(after: String, before: String, distance_Gte: Float, distance_Lte: Float, first: Int, last: Int, offset: Int): RaceNodeConnection!
    slug: String
    soldOut: Boolean
    source: String
    "set if the event has been verified by the admin"
    verifiedAt: DateTime
    waterTemp: Float
    website: String!
    withRanking: Boolean
}

type EventNodeConnection {
    "Contains the nodes in this connection."
    edges: [EventNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `EventNode` and its cursor."
type EventNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: EventNode
}

type LocationMutationPayload {
    clientMutationId: String
    location: LocationNode
}

type LocationNode implements Node {
    city: String!
    country: LocationCountry!
    events(after: String, before: String, dateEnd_Gte: Date, dateEnd_Lte: Date, dateStart_Gte: Date, dateStart_Lte: Date, first: Int, last: Int, location: ID, location_City: String, location_City_Icontains: String, location_Country: String, name: String, offset: Int, website: String): EventNodeConnection!
    headerPhoto: String
    "The ID of the object."
    id: ID!
    lat: Float
    lng: Float
    waterName: String
    waterType: LocationWaterType
}

type LocationNodeConnection {
    "Contains the nodes in this connection."
    edges: [LocationNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `LocationNode` and its cursor."
type LocationNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: LocationNode
}

type Mutation {
    """

    Register user with fields defined in the settings.

    If the email field of the user model is part of the
    registration fields (default), check if there is
    no user with that email or as a secondary email.

    If it exists, it does not register the user,
    even if the email field is not defined as unique
    (default of the default django user model).

    When creating the user, it also creates a `UserStatus`
    related to that user, making it possible to track
    if the user is archived, verified and has a secondary
    email.

    Send account verification email.

    If allowed to not verified users login, return token.
    """
    register(email: String!, password1: String!, password2: String!, username: String!): Register
    """

    Obtain JSON web token for given user.

    Allow to perform login with different fields,
    and secondary email if set. The fields are
    defined on settings.

    Not verified users can login by default. This
    can be changes on settings.

    If user is archived, make it unarchive and
    return `unarchiving=True` on output.
    """
    tokenAuth(email: String, password: String!, username: String): ObtainJSONWebToken
    updateEvent(input: EventMutationInput!): EventMutationPayload
    updateLocation(input: LocationMutationInput!): LocationMutationPayload
    updateRace(input: RaceMutationInput!): RaceMutationPayload
    """

    Verify user account.

    Receive the token that was sent by email.
    If the token is valid, make the user verified
    by making the `user.status.verified` field true.
    """
    verifyAccount(token: String!): VerifyAccount
}

"""

Obtain JSON web token for given user.

Allow to perform login with different fields,
and secondary email if set. The fields are
defined on settings.

Not verified users can login by default. This
can be changes on settings.

If user is archived, make it unarchive and
return `unarchiving=True` on output.
"""
type ObtainJSONWebToken {
    errors: ExpectedErrorType
    refreshToken: String
    success: Boolean
    token: String
    unarchiving: Boolean
    user: UserNode
}

type OrganizerNode implements Node {
    "The ID of the object."
    id: ID!
    logo: String
    name: String!
    slug: String
    website: String!
}

type OrganizerNodeConnection {
    "Contains the nodes in this connection."
    edges: [OrganizerNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `OrganizerNode` and its cursor."
type OrganizerNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: OrganizerNode
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Query {
    _debug: DjangoDebug
    allEvents(after: String, before: String, dateFrom: Date, dateTo: Date, first: Int, last: Int, location: ID, name: String, offset: Int, raceDistanceGte: Float, raceDistanceLte: Float, races: [ID], slug: String, website: String): EventNodeConnection
    allLocations(after: String, before: String, city: String, country: String, dateFrom: Date, dateTo: Date, events: [ID], first: Int, last: Int, lat: Float, lng: Float, offset: Int, raceDistanceGte: Float, raceDistanceLte: Float, waterName: String, waterType: String): LocationNodeConnection
    allOrganizers(after: String, before: String, first: Int, last: Int, name: String, offset: Int, slug: String): OrganizerNodeConnection
    "The ID of the object"
    event(id: ID!): EventNode
    "The ID of the object"
    location(id: ID!): LocationNode
    locationsFiltered(dateFrom: Date, dateTo: Date, eventSlug: String, keyword: String, organizerId: ID, organizerSlug: String, raceDistanceGte: Float, raceDistanceLte: Float): [LocationNode]
    me: UserNode
    "The ID of the object"
    organizer(id: ID!): OrganizerNode
    "The ID of the object"
    race(id: ID!): RaceNode
    statistics: Statistics
    "The ID of the object"
    user(id: ID!): UserNode
    users(after: String, before: String, email: String, first: Int, isActive: Boolean, last: Int, offset: Int, status_Archived: Boolean, status_SecondaryEmail: String, status_Verified: Boolean, username: String, username_Icontains: String, username_Istartswith: String): UserNodeConnection
}

type RaceMutationPayload {
    clientMutationId: String
    race: RaceNode
}

type RaceNode implements Node {
    "Coordinates (lat/lng) of track"
    coordinates: [[Float!]]
    "Date of event, in local time"
    date: Date!
    distance: Float!
    "The ID of the object."
    id: ID!
    name: String
    priceCurrency: RacePriceCurrency!
    priceValue: String
    "Date and time of event, in local time"
    raceTime: Time
    wetsuit: RaceWetsuit
}

type RaceNodeConnection {
    "Contains the nodes in this connection."
    edges: [RaceNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `RaceNode` and its cursor."
type RaceNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: RaceNode
}

"""

Register user with fields defined in the settings.

If the email field of the user model is part of the
registration fields (default), check if there is
no user with that email or as a secondary email.

If it exists, it does not register the user,
even if the email field is not defined as unique
(default of the default django user model).

When creating the user, it also creates a `UserStatus`
related to that user, making it possible to track
if the user is archived, verified and has a secondary
email.

Send account verification email.

If allowed to not verified users login, return token.
"""
type Register {
    errors: ExpectedErrorType
    refreshToken: String
    success: Boolean
    token: String
}

type Statistics {
    countriesCount: Int
    eventCount: Int
    raceCount: Int
}

type UserNode implements Node {
    archived: Boolean
    dateJoined: DateTime!
    email: String!
    "Author who has done the last edit"
    eventSet(after: String, before: String, dateEnd_Gte: Date, dateEnd_Lte: Date, dateStart_Gte: Date, dateStart_Lte: Date, first: Int, last: Int, location: ID, location_City: String, location_City_Icontains: String, location_Country: String, name: String, offset: Int, website: String): EventNodeConnection!
    firstName: String!
    "The ID of the object."
    id: ID!
    "Designates whether this user should be treated as active. Unselect this instead of deleting accounts."
    isActive: Boolean!
    "Designates whether the user can log into this admin site."
    isStaff: Boolean!
    lastLogin: DateTime
    lastName: String!
    pk: Int
    secondaryEmail: String
    "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."
    username: String!
    verified: Boolean
}

type UserNodeConnection {
    "Contains the nodes in this connection."
    edges: [UserNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `UserNode` and its cursor."
type UserNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: UserNode
}

"""

Verify user account.

Receive the token that was sent by email.
If the token is valid, make the user verified
by making the `user.status.verified` field true.
"""
type VerifyAccount {
    errors: ExpectedErrorType
    success: Boolean
}

"An enumeration."
enum EventEntryQuality {
    "Complete"
    COMPLETE
    "Incomplete"
    INCOMPLETE
}

"An enumeration."
enum LocationCountry {
    "Andorra"
    AD
    "United Arab Emirates"
    AE
    "Afghanistan"
    AF
    "Antigua and Barbuda"
    AG
    "Anguilla"
    AI
    "Albania"
    AL
    "Armenia"
    AM
    "Angola"
    AO
    "Antarctica"
    AQ
    "Argentina"
    AR
    "American Samoa"
    AS
    "Austria"
    AT
    "Australia"
    AU
    "Aruba"
    AW
    "Åland Islands"
    AX
    "Azerbaijan"
    AZ
    "Bosnia and Herzegovina"
    BA
    "Barbados"
    BB
    "Bangladesh"
    BD
    "Belgium"
    BE
    "Burkina Faso"
    BF
    "Bulgaria"
    BG
    "Bahrain"
    BH
    "Burundi"
    BI
    "Benin"
    BJ
    "Saint Barthélemy"
    BL
    "Bermuda"
    BM
    "Brunei"
    BN
    "Bolivia"
    BO
    "Bonaire, Sint Eustatius and Saba"
    BQ
    "Brazil"
    BR
    "Bahamas"
    BS
    "Bhutan"
    BT
    "Bouvet Island"
    BV
    "Botswana"
    BW
    "Belarus"
    BY
    "Belize"
    BZ
    "Canada"
    CA
    "Cocos (Keeling) Islands"
    CC
    "Congo (the Democratic Republic of the)"
    CD
    "Central African Republic"
    CF
    "Congo"
    CG
    "Switzerland"
    CH
    "Côte d'Ivoire"
    CI
    "Cook Islands"
    CK
    "Chile"
    CL
    "Cameroon"
    CM
    "China"
    CN
    "Colombia"
    CO
    "Costa Rica"
    CR
    "Cuba"
    CU
    "Cabo Verde"
    CV
    "Curaçao"
    CW
    "Christmas Island"
    CX
    "Cyprus"
    CY
    "Czechia"
    CZ
    "Germany"
    DE
    "Djibouti"
    DJ
    "Denmark"
    DK
    "Dominica"
    DM
    "Dominican Republic"
    DO
    "Algeria"
    DZ
    "Ecuador"
    EC
    "Estonia"
    EE
    "Egypt"
    EG
    "Western Sahara"
    EH
    "Eritrea"
    ER
    "Spain"
    ES
    "Ethiopia"
    ET
    "Finland"
    FI
    "Fiji"
    FJ
    "Falkland Islands (Malvinas)"
    FK
    "Micronesia (Federated States of)"
    FM
    "Faroe Islands"
    FO
    "France"
    FR
    "Gabon"
    GA
    "United Kingdom"
    GB
    "Grenada"
    GD
    "Georgia"
    GE
    "French Guiana"
    GF
    "Guernsey"
    GG
    "Ghana"
    GH
    "Gibraltar"
    GI
    "Greenland"
    GL
    "Gambia"
    GM
    "Guinea"
    GN
    "Guadeloupe"
    GP
    "Equatorial Guinea"
    GQ
    "Greece"
    GR
    "South Georgia and the South Sandwich Islands"
    GS
    "Guatemala"
    GT
    "Guam"
    GU
    "Guinea-Bissau"
    GW
    "Guyana"
    GY
    "Hong Kong"
    HK
    "Heard Island and McDonald Islands"
    HM
    "Honduras"
    HN
    "Croatia"
    HR
    "Haiti"
    HT
    "Hungary"
    HU
    "Indonesia"
    ID
    "Ireland"
    IE
    "Israel"
    IL
    "Isle of Man"
    IM
    "India"
    IN
    "British Indian Ocean Territory"
    IO
    "Iraq"
    IQ
    "Iran"
    IR
    "Iceland"
    IS
    "Italy"
    IT
    "Jersey"
    JE
    "Jamaica"
    JM
    "Jordan"
    JO
    "Japan"
    JP
    "Kenya"
    KE
    "Kyrgyzstan"
    KG
    "Cambodia"
    KH
    "Kiribati"
    KI
    "Comoros"
    KM
    "Saint Kitts and Nevis"
    KN
    "North Korea"
    KP
    "South Korea"
    KR
    "Kuwait"
    KW
    "Cayman Islands"
    KY
    "Kazakhstan"
    KZ
    "Laos"
    LA
    "Lebanon"
    LB
    "Saint Lucia"
    LC
    "Liechtenstein"
    LI
    "Sri Lanka"
    LK
    "Liberia"
    LR
    "Lesotho"
    LS
    "Lithuania"
    LT
    "Luxembourg"
    LU
    "Latvia"
    LV
    "Libya"
    LY
    "Morocco"
    MA
    "Monaco"
    MC
    "Moldova"
    MD
    "Montenegro"
    ME
    "Saint Martin (French part)"
    MF
    "Madagascar"
    MG
    "Marshall Islands"
    MH
    "North Macedonia"
    MK
    "Mali"
    ML
    "Myanmar"
    MM
    "Mongolia"
    MN
    "Macao"
    MO
    "Northern Mariana Islands"
    MP
    "Martinique"
    MQ
    "Mauritania"
    MR
    "Montserrat"
    MS
    "Malta"
    MT
    "Mauritius"
    MU
    "Maldives"
    MV
    "Malawi"
    MW
    "Mexico"
    MX
    "Malaysia"
    MY
    "Mozambique"
    MZ
    "Namibia"
    NA
    "New Caledonia"
    NC
    "Niger"
    NE
    "Norfolk Island"
    NF
    "Nigeria"
    NG
    "Nicaragua"
    NI
    "Netherlands"
    NL
    "Norway"
    NO
    "Nepal"
    NP
    "Nauru"
    NR
    "Niue"
    NU
    "New Zealand"
    NZ
    "Oman"
    OM
    "Panama"
    PA
    "Peru"
    PE
    "French Polynesia"
    PF
    "Papua New Guinea"
    PG
    "Philippines"
    PH
    "Pakistan"
    PK
    "Poland"
    PL
    "Saint Pierre and Miquelon"
    PM
    "Pitcairn"
    PN
    "Puerto Rico"
    PR
    "Palestine, State of"
    PS
    "Portugal"
    PT
    "Palau"
    PW
    "Paraguay"
    PY
    "Qatar"
    QA
    "Réunion"
    RE
    "Romania"
    RO
    "Serbia"
    RS
    "Russia"
    RU
    "Rwanda"
    RW
    "Saudi Arabia"
    SA
    "Solomon Islands"
    SB
    "Seychelles"
    SC
    "Sudan"
    SD
    "Sweden"
    SE
    "Singapore"
    SG
    "Saint Helena, Ascension and Tristan da Cunha"
    SH
    "Slovenia"
    SI
    "Svalbard and Jan Mayen"
    SJ
    "Slovakia"
    SK
    "Sierra Leone"
    SL
    "San Marino"
    SM
    "Senegal"
    SN
    "Somalia"
    SO
    "Suriname"
    SR
    "South Sudan"
    SS
    "Sao Tome and Principe"
    ST
    "El Salvador"
    SV
    "Sint Maarten (Dutch part)"
    SX
    "Syria"
    SY
    "Eswatini"
    SZ
    "Turks and Caicos Islands"
    TC
    "Chad"
    TD
    "French Southern Territories"
    TF
    "Togo"
    TG
    "Thailand"
    TH
    "Tajikistan"
    TJ
    "Tokelau"
    TK
    "Timor-Leste"
    TL
    "Turkmenistan"
    TM
    "Tunisia"
    TN
    "Tonga"
    TO
    "Turkey"
    TR
    "Trinidad and Tobago"
    TT
    "Tuvalu"
    TV
    "Taiwan"
    TW
    "Tanzania"
    TZ
    "Ukraine"
    UA
    "Uganda"
    UG
    "United States Minor Outlying Islands"
    UM
    "United States of America"
    US
    "Uruguay"
    UY
    "Uzbekistan"
    UZ
    "Holy See"
    VA
    "Saint Vincent and the Grenadines"
    VC
    "Venezuela"
    VE
    "Virgin Islands (British)"
    VG
    "Virgin Islands (U.S.)"
    VI
    "Vietnam"
    VN
    "Vanuatu"
    VU
    "Wallis and Futuna"
    WF
    "Samoa"
    WS
    "Yemen"
    YE
    "Mayotte"
    YT
    "South Africa"
    ZA
    "Zambia"
    ZM
    "Zimbabwe"
    ZW
}

"An enumeration."
enum LocationWaterType {
    "Lake"
    LAKE
    "Pool"
    POOL
    "River"
    RIVER
    "Sea"
    SEA
}

"An enumeration."
enum RacePriceCurrency {
    "UAE Dirham"
    AED
    "Afghani"
    AFN
    "Lek"
    ALL
    "Armenian Dram"
    AMD
    "Netherlands Antillian Guilder"
    ANG
    "Kwanza"
    AOA
    "Argentine Peso"
    ARS
    "Australian Dollar"
    AUD
    "Aruban Guilder"
    AWG
    "Azerbaijanian Manat"
    AZN
    "Convertible Marks"
    BAM
    "Barbados Dollar"
    BBD
    "Taka"
    BDT
    "Bulgarian Lev"
    BGN
    "Bahraini Dinar"
    BHD
    "Burundi Franc"
    BIF
    "Bermudian Dollar (customarily known as Bermuda Dollar)"
    BMD
    "Brunei Dollar"
    BND
    "Boliviano"
    BOB
    "Mvdol"
    BOV
    "Brazilian Real"
    BRL
    "Bahamian Dollar"
    BSD
    "Bhutanese ngultrum"
    BTN
    "Pula"
    BWP
    "Belarussian Ruble"
    BYN
    "Belarussian Ruble"
    BYR
    "Belize Dollar"
    BZD
    "Canadian Dollar"
    CAD
    "Congolese franc"
    CDF
    "WIR Euro"
    CHE
    "Swiss Franc"
    CHF
    "WIR Franc"
    CHW
    "Unidad de Fomento"
    CLF
    "Chilean peso"
    CLP
    "Yuan Renminbi"
    CNY
    "Colombian peso"
    COP
    "Unidad de Valor Real"
    COU
    "Costa Rican Colon"
    CRC
    "Cuban convertible peso"
    CUC
    "Cuban Peso"
    CUP
    "Cape Verde Escudo"
    CVE
    "Czech Koruna"
    CZK
    "Djibouti Franc"
    DJF
    "Danish Krone"
    DKK
    "Dominican Peso"
    DOP
    "Algerian Dinar"
    DZD
    "Egyptian Pound"
    EGP
    "Nakfa"
    ERN
    "Ethiopian Birr"
    ETB
    "Euro"
    EUR
    "Fiji Dollar"
    FJD
    "Falkland Islands Pound"
    FKP
    "Pound Sterling"
    GBP
    "Lari"
    GEL
    "Ghana Cedi"
    GHS
    "Gibraltar Pound"
    GIP
    "Dalasi"
    GMD
    "Guinea Franc"
    GNF
    "Quetzal"
    GTQ
    "Guyana Dollar"
    GYD
    "Hong Kong Dollar"
    HKD
    "Lempira"
    HNL
    "Croatian Kuna"
    HRK
    "Haitian gourde"
    HTG
    "Forint"
    HUF
    "Rupiah"
    IDR
    "New Israeli Sheqel"
    ILS
    "Isle of Man Pound"
    IMP
    "Indian Rupee"
    INR
    "Iraqi Dinar"
    IQD
    "Iranian Rial"
    IRR
    "Iceland Krona"
    ISK
    "Jamaican Dollar"
    JMD
    "Jordanian Dinar"
    JOD
    "Yen"
    JPY
    "Kenyan Shilling"
    KES
    "Som"
    KGS
    "Riel"
    KHR
    "Comoro Franc"
    KMF
    "North Korean Won"
    KPW
    "Won"
    KRW
    "Kuwaiti Dinar"
    KWD
    "Cayman Islands Dollar"
    KYD
    "Tenge"
    KZT
    "Kip"
    LAK
    "Lebanese Pound"
    LBP
    "Sri Lanka Rupee"
    LKR
    "Liberian Dollar"
    LRD
    "Lesotho loti"
    LSL
    "Lithuanian Litas"
    LTL
    "Latvian Lats"
    LVL
    "Libyan Dinar"
    LYD
    "Moroccan Dirham"
    MAD
    "Moldovan Leu"
    MDL
    "Malagasy Ariary"
    MGA
    "Denar"
    MKD
    "Kyat"
    MMK
    "Tugrik"
    MNT
    "Pataca"
    MOP
    "Ouguiya"
    MRO
    "Mauritius Rupee"
    MUR
    "Rufiyaa"
    MVR
    "Malawian Kwacha"
    MWK
    "Mexican peso"
    MXN
    "Mexican Unidad de Inversion (UDI)"
    MXV
    "Malaysian Ringgit"
    MYR
    "Metical"
    MZN
    "Namibian Dollar"
    NAD
    "Naira"
    NGN
    "Cordoba Oro"
    NIO
    "Norwegian Krone"
    NOK
    "Nepalese Rupee"
    NPR
    "New Zealand Dollar"
    NZD
    "Rial Omani"
    OMR
    "Balboa"
    PAB
    "Nuevo Sol"
    PEN
    "Kina"
    PGK
    "Philippine Peso"
    PHP
    "Pakistan Rupee"
    PKR
    "Zloty"
    PLN
    "Guarani"
    PYG
    "Qatari Rial"
    QAR
    "New Leu"
    RON
    "Serbian Dinar"
    RSD
    "Russian Ruble"
    RUB
    "Rwanda Franc"
    RWF
    "Saudi Riyal"
    SAR
    "Solomon Islands Dollar"
    SBD
    "Seychelles Rupee"
    SCR
    "Sudanese Pound"
    SDG
    "Swedish Krona"
    SEK
    "Singapore Dollar"
    SGD
    "Saint Helena Pound"
    SHP
    "Leone"
    SLL
    "Somali Shilling"
    SOS
    "Surinam Dollar"
    SRD
    "South Sudanese Pound"
    SSP
    "Dobra"
    STD
    "El Salvador Colon"
    SVC
    "Syrian Pound"
    SYP
    "Lilangeni"
    SZL
    "Baht"
    THB
    "Somoni"
    TJS
    "Manat"
    TMM
    "Turkmenistan New Manat"
    TMT
    "Tunisian Dinar"
    TND
    "Paanga"
    TOP
    "Turkish Lira"
    TRY
    "Trinidad and Tobago Dollar"
    TTD
    "Tuvalu dollar"
    TVD
    "New Taiwan Dollar"
    TWD
    "Tanzanian Shilling"
    TZS
    "Hryvnia"
    UAH
    "Uganda Shilling"
    UGX
    "US Dollar"
    USD
    "US Dollar (Next day)"
    USN
    "Uruguay Peso en Unidades Indexadas (URUIURUI)"
    UYI
    "Uruguayan peso"
    UYU
    "Uzbekistan Sum"
    UZS
    "Bolivar Fuerte"
    VEF
    "Dong"
    VND
    "Vatu"
    VUV
    "Tala"
    WST
    "CFA franc BEAC"
    XAF
    "Silver"
    XAG
    "Gold"
    XAU
    "Bond Markets Units European Composite Unit (EURCO)"
    XBA
    "European Monetary Unit (E.M.U.-6)"
    XBB
    "European Unit of Account 9(E.U.A.-9)"
    XBC
    "European Unit of Account 17(E.U.A.-17)"
    XBD
    "East Caribbean Dollar"
    XCD
    "SDR"
    XDR
    "Gold-Franc"
    XFO
    "UIC-Franc"
    XFU
    "CFA Franc BCEAO"
    XOF
    "Palladium"
    XPD
    "CFP Franc"
    XPF
    "Platinum"
    XPT
    "Sucre"
    XSU
    "Codes specifically reserved for testing purposes"
    XTS
    "ADB Unit of Account"
    XUA
    "The codes assigned for transactions where no currency is involved"
    XXX
    "Yemeni Rial"
    YER
    "Rand"
    ZAR
    "Zambian Kwacha"
    ZMK
    "Zambian Kwacha"
    ZMW
    "Zimbabwe Dollar A/06"
    ZWD
    "Zimbabwe dollar A/09"
    ZWL
    "Zimbabwe dollar A/08"
    ZWN
}

"An enumeration."
enum RaceWetsuit {
    "Compulsory"
    COMPULSORY
    "Optional"
    OPTIONAL
    "Prohibited"
    PROHIBITED
}

input EventMutationInput {
    clientMutationId: String
    id: ID
    name: String!
}

input LocationMutationInput {
    city: String!
    clientMutationId: String
    id: ID
}

input RaceMutationInput {
    clientMutationId: String
    coordinates: [Float]!
    id: ID
}


"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

"""
Errors messages and codes mapped to
fields or non fields errors.
Example:
{
field_name: [
{
"message": "error message",
"code": "error_code"
            }
],
other_field: [
{
"message": "error message",
"code": "error_code"
            }
],
nonFieldErrors: [
{
"message": "error message",
"code": "error_code"
            }
]
}
"""
scalar ExpectedErrorType
